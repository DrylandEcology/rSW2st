% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_netCDF.R
\name{create_netCDF}
\alias{create_netCDF}
\title{Create a \var{netCDF} file (with or without data)}
\usage{
create_netCDF(
  filename,
  xyspace,
  data = NULL,
  data_str = c("xyzt", "xyt", "xyz", "xy", "szt", "st", "sz", "s"),
  data_dims = get_data_dims(data_str, dim(data)),
  data_type = c("double", "float", "integer", "short", "byte", "char"),
  var_attributes = list(name = "", standard_name = "", long_name = "", units = "",
    grid_mapping = "crs", cell_methods = "", cell_measures = ""),
  xy_attributes = list(name = c("lon", "lat"), standard_name = c("longitude",
    "latitude"), long_name = c("Longitude", "Latitude"), units = c("degrees_east",
    "degrees_north")),
  crs_attributes = list(crs_wkt = sf::st_crs("OGC:CRS84")$Wkt, grid_mapping_name =
    "latitude_longitude", longitude_of_prime_meridian = 0, semi_major_axis = 6378137,
    inverse_flattening = 298.257223563),
  check_crs = TRUE,
  time_values = NULL,
  type_timeaxis = c("timeseries", "climatology"),
  time_attributes = list(units = "days since 1900-01-01", calendar = "standard", unlim
    = FALSE),
  time_bounds = matrix(NA, nrow = length(time_values), ncol = 2),
  vertical_values = NULL,
  vertical_attributes = list(units = "", positive = "down"),
  vertical_bounds = matrix(NA, nrow = length(vertical_values), ncol = 2),
  global_attributes = list(title = "Title"),
  overwrite = FALSE,
  nc_compression = FALSE,
  nc_shuffle = TRUE,
  nc_deflate = 5,
  nc_chunks = "by_zt",
  verbose = FALSE
)
}
\arguments{
\item{filename}{A character string. The name of the \var{netCDF} file.}

\item{xyspace}{An object that describes the \var{xy-space} of the
\var{netCDF} file.
If \code{xyspace} does not contain a \var{crs},
then it is assumed that the \var{crs} is \var{crs_attributes[["crs_wkt"]]}.
If data are gridded, then passed to \code{\link{xy_from_grid}};
if non-gridded, then passed to \code{\link{as_points}}.}

\item{data}{A numeric array or vector (optional). A vector is converted
to a one-column matrix.}

\item{data_str}{A character string describing the dimensions of \code{data}
where \var{"xy"} stands for \var{x} and \var{y} spatial dimensions
if the spatial structure is gridded,
while \var{"s"} stands for \var{site} if the spatial structure are
discrete points;
\var{z} stands for a vertical dimension; and \var{t} stands for a
temporal dimension.}

\item{data_dims}{A list as returned by \code{\link{get_data_dims}}.
If \code{NULL} and \code{data} is not missing, then calculated from
\code{data}.}

\item{data_type}{A character string. The \var{netCDF} data type.}

\item{var_attributes}{A list of named character strings defining the
\var{netCDF} variable(s).
Elements \var{name} and \var{units} are required.}

\item{xy_attributes}{A list of named character strings defining the
\var{netCDF} dimensions for the \var{xy-space}.
Elements \var{name}, \var{standard_name}, \var{long_name},
and \var{units} are required.}

\item{crs_attributes}{A list of named character strings defining the
\var{netCDF} \var{crs} of the \var{xy-space}.
Elements \var{crs_wkt} and \var{grid_mapping_name} are required.}

\item{check_crs}{A logical value. If \code{TRUE} then check that
the \var{crs} provided via \code{crs_attributes} matches the ones
from \code{locations} and \code{grid} if available.}

\item{time_values}{A numeric vector or \code{NULL}. The values along the
time dimension (if present).
In units as described by \code{time_attributes}.}

\item{type_timeaxis}{A character string. Describing if the time dimension
represents a time series or a climatological time.}

\item{time_attributes}{A list of named character strings defining the
\var{netCDF} time dimension.
Elements \var{calendar}, \var{units}, and \var{unlim} are required.}

\item{time_bounds}{A numeric vector or two-dimensional matrix.
The start and end of each time (or climatological) unit.}

\item{vertical_values}{A numeric vector or \code{NULL}. The values along the
vertical dimension (if present).
In units as described by \code{vertical_attributes}.}

\item{vertical_attributes}{A list of named character strings defining the
\var{netCDF} vertical dimension, e.g., soil depth.
Elements \var{units} and \var{positive} are required.}

\item{vertical_bounds}{A numeric vector or two-dimensional matrix.
The upper/lower limits of each vertical unit.}

\item{global_attributes}{A list of named character strings defining the
global attributes of the \var{netCDF}.}

\item{overwrite}{A logical value. If \code{TRUE}, file will be overwritten
if it already exists.}

\item{nc_compression}{A logical value. If \code{TRUE}, then the \var{netCDF}
is created using compression arguments
\code{nc_shuffle}, \code{nc_deflate}, and \var{nc_chunks}. Compression
is turned off by default.}

\item{nc_shuffle}{A logical value. If \code{TRUE}, then the shuffle filter
is turned on which can improve compression.
Used only if \code{nc_compression} is activated \code{TRUE}.}

\item{nc_deflate}{An integer between 1 and 9 (with increasing)
compression or \code{NA} to turn off compression.
Used only if \code{nc_compression} is activated \code{TRUE}.}

\item{nc_chunks}{A character string, \code{NA}, or an integer vector.
See details. The default \var{"by_zt"} is to create chunks for the
entire \var{xy-space} and for each vertical and each time step.
Used only if \code{nc_compression} is activated \code{TRUE}.}

\item{verbose}{A logical value.}
}
\value{
This function is used for the side-effect of creating a \var{netCDF}
  file.
  Data values are written to the file if provided as argument \code{data}.
}
\description{
The user describes a data array and specifies
spatial, vertical, and time information,
and metadata to create a \var{netCDF} in \var{netcdf-4 format}
according to \var{CF-1.8} standards.
}
\section{Details}{

Values can be written to the file at a later time using function
\code{\link{populate_netCDF}}.

The created \var{netCDF} is suitable for three data situations:
\enumerate{
   \item one variable and \var{xy-space}, time and vertical dimensions
   \item one variable and \var{xy-space} and time or vertical dimensions
   \item one or multiple variables and \var{xy-space} dimensions
         without time/vertical dimensions
}
}

\section{Spatial setup}{

Spatial information about the \var{xy-space} is derived from the arguments
\code{xyspace}, \code{xy_attributes}, \code{crs_attributes}, \code{data_str},
and \code{data_dims}.

The \var{xy-space} is either gridded (determined by the
first two characters of \code{data_str} equal to \var{"xy"}),
or list of discrete points/sites
(determined by the first character of \code{data_str} equal to \var{"s"}).

\itemize{
  \item The gridded situation creates \var{x} and \var{y} dimensions and
    associated variables in the \var{netCDF} file.
    The size of the \var{xy-space} must agree
    with the elements \var{"n_x"} and \var{"n_y"} of \code{data_dims} and,
    thus, with the two first dimensions of \code{data}, if available.

  \item The discrete point/site situation creates a \var{site} dimension and
    associated variable as well as \var{x} and \var{y} variables
    for the spatial coordinate values of the sites; see
    \href{http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#point-data}{CF point-data}.
    The code will add a \var{coordinates} attribute to the variable(s) and
    a \var{featureType = "point"} global attribute.
    The size of the \var{xy-space}, i.e., the number of sites, must agree
    with the element \var{"n_s"} of \code{data_dims} and,
    thus, with the first dimension of \code{data}, if available.
}

The \var{crs} are checked by default (see argument \code{check_crs}) for
consistency among \code{crs_atttributes}, \code{locations}, and/or
\code{grid}. However, this check may fail when \code{locations} and/or
\code{grid} use a \var{PROJ.4} representation that doesn't compare well with
a \var{WKT2} representation provided by \code{crs_atttributes} even if they
are the same. Turn off these checks in such cases.
}

\section{Spatial dimensions of data}{

For the gridded situation, \code{data} array must be arranged
in "expanded" spatial format, i.e.,
the two dimensions of the \code{data} array span to the
\var{xy-space}.
The first dimension, i.e., \var{X}, matches \var{gridcells}
along \var{longitude} or a projected \var{x} coordinate and
the second dimension, i.e., \var{Y}, matches \var{gridcells}
along \var{latitude} or a projected \var{y} coordinate.
The \code{xy_attributes[["name"]][1:2]} defines the names of
the \var{x} and \var{y} dimensions/variables.

However, "gridded" data objects are frequently organized by "collapsed"
\var{x} and \var{y} dimensions, e.g., to achieve a sparse representation.
Use the function \code{\link{convert_xyspace}} to expand sparse data arrays
before their use by function \code{\link{create_netCDF}}.

For the discrete point/site situation, \code{data} array must be arranged
in "collapsed" spatial format, i.e.,
the first dimension (rows) of \code{data} corresponds to the number of
points/sites.
}

\section{Non-spatial dimensions of data}{

The first non-spatial dimension of a \code{data} array, if present,
corresponds to
\itemize{
  \item multiple variables, if \code{data_str} is \var{"xy"} or \var{"s"}
  \item time dimension, if \code{data_str} is \var{"xyt"} or \var{"st"}
  \item vertical dimension, if \code{data_str} is
        \var{"xyzt"}, \var{"xyz"}, \var{"szt"}, or \var{"sz"}
}

The second non-spatial dimension of the \code{data} array, if present,
corresponds to the time dimension;
this situation arises only in the presence of
both a time and vertical dimension,
i.e., \code{data_str} is \var{"xyzt"} or \var{"szt"}.
}

\section{Variables}{

Use \var{CMIP6} standard variable names, units, etc., where available.
Standardized variable names can be searched in the
\href{https://github.com/PCMDI/cmip6-cmor-tables/tree/master/Tables}{CMIP6-cmor-tables}
}

\section{Chunking}{

The argument \code{nc_chunks} offers two auto-determined chunking schemes:
\describe{
  \item{"by_zt"}{
    create chunks for the entire \var{xy-space} and
    for each vertical and each time step
  }
  \item{"by_t"}{
    create chunks for the entire \var{xy-space} and all vertical steps
    (if present) and for each time step
  }
}
Alternatively, the user can provide an integer vector with a length
equal to the number of the dimensions according to \code{data_dims}.
}

\examples{
# Prepare data for examples
tmp_nc <- create_example_netCDFs(tempdir(), c("xyt", "szt"), "timeseries")
data_xyt <- read_netCDF(tmp_nc[["xyt"]], "array", xy_names = c("x", "y"))
data_szt <- read_netCDF(tmp_nc[["szt"]], "array", xy_names = c("x", "y"))

# Prepare attribute lists
nc_att_global <- list(
  title = "Example netCDF of package rSW2st",
  version = paste0("v", format(Sys.Date(), "\%Y\%m\%d")),
  source_id = "SOILWAT2",
  further_info_url = "https://github.com/DrylandEcology/",
  source_type = "LAND",
  realm = "land",
  product = "model-output",
  grid = "native Alberts projection grid with NAD83 datum",
  grid_label = "gn",
  nominal_resolution = "1 m"
)

nc_att_crs <- list(
  crs_wkt = sf::st_crs("EPSG:6350")$Wkt,
  grid_mapping_name = "albers_conical_equal_area",
  standard_parallel = c(29.5, 45.5),
  longitude_of_central_meridian = -96.0,
  latitude_of_projection_origin = 23.0,
  false_easting = 0.0,
  false_northing = 0.0,
  # GRS 1980 ellipsoid
  longitude_of_prime_meridian = 0,
  semi_major_axis = 6378137.0,
  inverse_flattening = 298.257222101
)

nc_att_xy <- list(
  name = c("x", "y"),
  standard_name = c("projection_x_coordinate", "projection_y_coordinate"),
  long_name = c("x coordinate of projection", "y coordinate of projection"),
  units = c("m", "m")
)

## Write netCDF for gridded data
tmp_nc[["xyt2"]] <- sub(".nc", "2.nc", tmp_nc[["xyt"]])

create_netCDF(
  filename = tmp_nc[["xyt2"]],
  xyspace = data_xyt[["xyspace"]],
  data = data_xyt[["data"]],
  data_str = "xyt",
  var_attributes = list(name = "sine", units = "1"),
  xy_attributes = nc_att_xy,
  crs_attributes = nc_att_crs,
  time_values = data_xyt[["time_values"]],
  type_timeaxis = "timeseries",
  global_attributes = nc_att_global
)

data_xyt2 <- read_netCDF(tmp_nc[["xyt2"]], "array", xy_names = c("x", "y"))
all.equal(data_xyt2, data_xyt)


## Write netCDF for discrete data
tmp_nc[["szt2"]] <- sub(".nc", "2.nc", tmp_nc[["szt"]])

create_netCDF(
  filename = tmp_nc[["szt2"]],
  xyspace = as.data.frame(data_szt[["xyspace"]][1:2]),
  data = data_szt[["data"]],
  data_str = "szt",
  var_attributes = list(name = "sine", units = "1"),
  xy_attributes = nc_att_xy,
  crs_attributes = nc_att_crs,
  time_values = data_szt[["time_values"]],
  type_timeaxis = "timeseries",
  vertical_values = data_szt[["vertical_values"]],
  vertical_attributes = list(units = "m", positive = "down"),
  global_attributes = nc_att_global
)


data_szt2 <- read_netCDF(tmp_nc[["szt2"]], "array", xy_names = c("x", "y"))
all.equal(data_szt2, data_szt)

# Cleanup
unlink(unlist(tmp_nc))

}
\references{
\href{https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html}{CF conventions}
}
\seealso{
\code{\link{populate_netCDF}}, \code{\link{read_netCDF}}
}
